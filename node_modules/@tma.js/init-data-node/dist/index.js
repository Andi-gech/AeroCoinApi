import { createHmac as b } from "node:crypto";
import { URLSearchParams as m } from "node:url";
function P(t, e) {
  return b(
    "sha256",
    b("sha256", "WebAppData").update(e).digest()
  ).update(t).digest().toString("hex");
}
function $(t) {
  const e = {};
  for (const n in t) {
    const r = t[n];
    r !== void 0 && (e[n] = r);
  }
  return e;
}
function S(t) {
  return t ? JSON.stringify({
    added_to_attachment_menu: t.addedToAttachmentMenu,
    allows_write_to_pm: t.allowsWriteToPm,
    first_name: t.firstName,
    id: t.id,
    is_bot: t.isBot,
    is_premium: t.isPremium,
    language_code: t.languageCode,
    last_name: t.lastName,
    photo_url: t.photoUrl,
    username: t.username
  }) : void 0;
}
function E({
  chat: t,
  receiver: e,
  user: n,
  ...r
}) {
  var o;
  return new m(
    $({
      auth_date: r.authDate ? (+r.authDate / 1e3 | 0).toString() : void 0,
      can_send_after: (o = r.canSendAfter) == null ? void 0 : o.toString(),
      chat: t ? JSON.stringify({
        id: t.id,
        type: t.type,
        title: t.title,
        photo_url: t.type,
        username: t.username
      }) : void 0,
      chat_instance: r.chatInstance,
      chat_type: r.chatType || void 0,
      hash: r.hash,
      query_id: r.queryId,
      receiver: S(e),
      start_param: r.startParam || void 0,
      user: S(n)
    })
  );
}
function B(t, e, n) {
  const r = E({
    ...t,
    authDate: n
  }), o = [...r.entries()].map(([i, u]) => `${i}=${u}`).sort();
  return r.append("hash", P(o.join(`
`), e)), r.toString();
}
function J(t, e, n = {}) {
  let r, o;
  const i = [];
  if (new m(
    typeof t == "string" || t instanceof m ? t : E(t)
  ).forEach((s, l) => {
    if (l === "hash") {
      o = s;
      return;
    }
    if (l === "auth_date") {
      const g = parseInt(s, 10);
      if (Number.isNaN(g))
        throw new TypeError('"auth_date" should present integer');
      r = new Date(g * 1e3);
    }
    i.push(`${l}=${s}`);
  }), !o)
    throw new Error('"hash" is empty or not found');
  if (!r)
    throw new Error('"auth_date" is empty or not found');
  const { expiresIn: u = 86400 } = n;
  if (u > 0 && +r + u * 1e3 < Date.now())
    throw new Error("Init data expired");
  if (i.sort(), P(i.join(`
`), e) !== o)
    throw new Error("Signature is invalid");
}
class _ extends Error {
  constructor(e, n, r) {
    super(n, { cause: r }), this.type = e, Object.setPrototypeOf(this, _.prototype);
  }
}
function y(t, e, n) {
  return new _(t, e, n);
}
const x = "ERR_UNEXPECTED_TYPE", N = "ERR_PARSE";
function h() {
  return y(x, "Value has unexpected type");
}
class w {
  constructor(e, n, r) {
    this.parser = e, this.isOptional = n, this.type = r;
  }
  /**
   * Attempts to parse passed value
   * @param value - value to parse.
   * @throws {SDKError} ERR_PARSE
   * @see ERR_PARSE
   */
  parse(e) {
    if (!(this.isOptional && e === void 0))
      try {
        return this.parser(e);
      } catch (n) {
        throw y(
          N,
          `Unable to parse value${this.type ? ` as ${this.type}` : ""}`,
          n
        );
      }
  }
  optional() {
    return this.isOptional = !0, this;
  }
}
function d(t, e) {
  return () => new w(t, !1, e);
}
const c = d((t) => {
  if (typeof t == "boolean")
    return t;
  const e = String(t);
  if (e === "1" || e === "true")
    return !0;
  if (e === "0" || e === "false")
    return !1;
  throw h();
}, "boolean");
function D(t, e) {
  const n = {};
  for (const r in t) {
    const o = t[r];
    if (!o)
      continue;
    let i, u;
    if (typeof o == "function" || "parse" in o)
      i = r, u = typeof o == "function" ? o : o.parse.bind(o);
    else {
      const { type: s } = o;
      i = o.from || r, u = typeof s == "function" ? s : s.parse.bind(s);
    }
    try {
      const s = u(e(i));
      s !== void 0 && (n[r] = s);
    } catch (s) {
      throw y(N, `Unable to parse field "${r}"`, s);
    }
  }
  return n;
}
function U(t) {
  let e = t;
  if (typeof e == "string" && (e = JSON.parse(e)), typeof e != "object" || e === null || Array.isArray(e))
    throw h();
  return e;
}
function p(t, e) {
  return new w((n) => {
    const r = U(n);
    return D(t, (o) => r[o]);
  }, !1, e);
}
const f = d((t) => {
  if (typeof t == "number")
    return t;
  if (typeof t == "string") {
    const e = Number(t);
    if (!Number.isNaN(e))
      return e;
  }
  throw h();
}, "number");
function R(t) {
  return /^#[\da-f]{6}$/i.test(t);
}
function T(t) {
  return /^#[\da-f]{3}$/i.test(t);
}
function q(t) {
  const e = t.replace(/\s/g, "").toLowerCase();
  if (R(e))
    return e;
  if (T(e)) {
    let r = "#";
    for (let o = 0; o < 3; o += 1)
      r += e[1 + o].repeat(2);
    return r;
  }
  const n = e.match(/^rgb\((\d{1,3}),(\d{1,3}),(\d{1,3})\)$/) || e.match(/^rgba\((\d{1,3}),(\d{1,3}),(\d{1,3}),\d{1,3}\)$/);
  if (!n)
    throw new Error(`Value "${t}" does not satisfy any of known RGB formats.`);
  return n.slice(1).reduce((r, o) => {
    const i = parseInt(o, 10).toString(16);
    return r + (i.length === 1 ? "0" : "") + i;
  }, "#");
}
const a = d((t) => {
  if (typeof t == "string" || typeof t == "number")
    return t.toString();
  throw h();
}, "string"), I = d((t) => q(a().parse(t)), "rgb");
p({
  req_id: a(),
  data: (t) => t === null ? t : a().optional().parse(t)
}), p({
  req_id: a(),
  result: (t) => t,
  error: a().optional()
}), p({ slug: a(), status: a() }), p({ status: a() }), p({ data: a().optional() }), p({
  theme_params: (t) => {
    const e = I().optional();
    return Object.entries(U(t)).reduce((n, [r, o]) => (n[r] = e.parse(o), n), {});
  }
}), p({
  height: f(),
  width: (t) => t == null ? window.innerWidth : f().parse(t),
  is_state_stable: c(),
  is_expanded: c()
}), p({ status: a() });
const O = d((t) => t instanceof Date ? t : new Date(f().parse(t) * 1e3), "Date");
function A(t, e) {
  return new w((n) => {
    if (typeof n != "string" && !(n instanceof URLSearchParams))
      throw h();
    const r = typeof n == "string" ? new URLSearchParams(n) : n;
    return D(t, (o) => {
      const i = r.get(o);
      return i === null ? void 0 : i;
    });
  }, !1, e);
}
const C = p({
  id: f(),
  type: a(),
  title: a(),
  photoUrl: {
    type: a().optional(),
    from: "photo_url"
  },
  username: a().optional()
}, "Chat").optional(), v = p({
  addedToAttachmentMenu: {
    type: c().optional(),
    from: "added_to_attachment_menu"
  },
  allowsWriteToPm: {
    type: c().optional(),
    from: "allows_write_to_pm"
  },
  firstName: {
    type: a(),
    from: "first_name"
  },
  id: f(),
  isBot: {
    type: c().optional(),
    from: "is_bot"
  },
  isPremium: {
    type: c().optional(),
    from: "is_premium"
  },
  languageCode: {
    type: a().optional(),
    from: "language_code"
  },
  lastName: {
    type: a().optional(),
    from: "last_name"
  },
  photoUrl: {
    type: a().optional(),
    from: "photo_url"
  },
  username: a().optional()
}, "User").optional();
function L() {
  return A({
    authDate: {
      type: O(),
      from: "auth_date"
    },
    canSendAfter: {
      type: f().optional(),
      from: "can_send_after"
    },
    chat: C,
    chatInstance: {
      type: a().optional(),
      from: "chat_instance"
    },
    chatType: {
      type: a().optional(),
      from: "chat_type"
    },
    hash: a(),
    queryId: {
      type: a().optional(),
      from: "query_id"
    },
    receiver: v,
    startParam: {
      type: a().optional(),
      from: "start_param"
    },
    user: v
  }, "InitData");
}
function V(t) {
  return L().parse(t);
}
export {
  V as parse,
  B as sign,
  P as signData,
  J as validate
};
//# sourceMappingURL=index.js.map
